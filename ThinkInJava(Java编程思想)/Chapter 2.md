# Chapter 2 一切都是对象

## 2.1 用句柄操作对象

在Java里,任何东西都可看作对象。因此,采用一种统一的语法,任何地方均可照搬不误。尽管将一切都“看作”对象,但操纵的标识符实际是指向一个对象的“句柄”(Handle)。类似C++的“引用”和“指针”。

String s;

这里创建的只是句柄,并不是对象。

## 2.2 所有对象都必须创建

创建句柄时,我们希望它同一个新对象连接。通常用new关键字达到这一目的。

String s = new String("asdf");

### 2.2.1  保存在什么地方

六个保存数据的地方：
1. 寄存器。只有汇编语言可以访问。
2. 堆栈。 创建程序时,Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码,以便向上和向下移动指针。这一限制无疑影响了程序的灵活性,所以尽管有些 Java 数据要保存在堆栈里——特别是对象句柄,但 Java 对象并不放到其中。
3. 堆。 保存了Java对象。
4. 静态存储。 “静态”(Static)是指“位于固定位置”(尽管也在RAM里)。程序运行期间,静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。
5. 常数存储。 常数值通常直接置于程序代码内部。永远都不会改变。
6. 非RAM存储。 数据完全独立于一个程序之外,则程序不运行时仍可存在,并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。

### 2.2.2 主要类型

数值类型全都是有符号(正负号)的,不存在无符号类型。

|主类型 |大小 |最小值 |最大值 |封装器类型|
|-|-|-|-|-|
|boolean |1 位 |- |- |Boolean|
|char |16 位 |Unicode 0 |Unicode 2^16-1 |Character|
|byte |8 位 |-128 |+127 |Byte(注释1)|
|short |16 位 |-2^15 |+2^15-1 |Short(注释1)|
|int |32 位 |-2^31 |+2^31-1 |Integer|
|long |64 位 |-2^63 |+2^63-1 |Long|
|float |32 位 |IEEE754 |IEEE754 |Float|
|double |64 位 |IEEE754 |IEEE754 |Double|
|Void |- |- |- |Void(注释1)|

注释1:到 Java 1.1 才有,1.0 版没有。

主数据类型拥有自己的“封装器”(wrapper)类。可以使用对应的封装器在堆内实例化一个对象表示主类型。
例如:
```
char c = 'x';
Character C = new Character('c');
也可以直接使用:
Character C = new Character('x');
```
高精度的计算:BigInteger和BigDecimal，没有对应的“主类型”。能对int或float做的操纵,对BigInteger和BigDecimal一样可以做。只是必须使用方法调用,不能使用运算符。BigInteger支持任意精度的整数。BigDecimal支持任意精度的定点数字。


### 2.2.3 Java的数组

创建对象数组时,实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值,并带有自己的关键字:null(空)。一旦Java看到null,就知道该句柄并未指向一个对象。正式使用前,必须为每个句柄都分配一个对象。


## 2.3 绝对不要清除对象

Java有一个特别的“垃圾收集器”,它会查找用new创建的所有对象,并辨别其中哪些不再被引用。随后,它会自动释放由那些闲置对象占据的内存,以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象,一旦不再需要它们,它们就会自动离去。

## 2.4 新建数据类型:类

关键字“class”。

1. 主成员的默认值

若某个主数据类型属于一个类成员,那么即使不明确(显式)进行初始化,也可以保证它们获得一个默认值。

|主类型 |默认值|
|-|-|
|Boolean |false|
|Char |'\u0000'(null)|
|byte |(byte)0|
|short |(short)0|
|int |0|
|long |0L|
|float |0.0f|
|double 0.0d|

## 2.5 方法、自变量和返回值

Java的“方法”决定了一个对象能够接收的消息。最基本的形式:
```
返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */}
```
Java的方法只能作为类的一部分创建。

## 2.6 构建Java程序

### 2.6.1 名字的可见性
Java的设计者鼓励程序员反转使用自己的Internet域名,因为它们肯定是独一无二的。由于我的域名是BruceEckel.com,所以实用工具库就可命名为com.bruceeckel.utility.foibles。反转了域名后,可将点号想象成子目录。
目前的整个软件包都以小写字母为标准。

### 2.6.2 使用其他组件

import的作用是指示编译器导入一个“包”——或者说一个“类库”。

直接采用来自标准Java库的组件(部件)即可,它们是与编译器配套提供的。使用这些组件时,没有必要关心冗长的保留域名;举个例子来说,只需象下面这样写一行代码即可:
```
import java.util.Vector;
```
可使用“\*”通配符。如下所示:
```
import java.util.*;
```

### 2.6.3 static关键字

两种不需要创建对象的情形：
1. 只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象,甚至根本不创建对象。
2. 需要一个特殊的方法,它没有与这个类的任何对象关联。也就是说,即使没有创建对象,也需要一个能调用的方法。
为满足这两方面的要求,可使用static(静态)关键字。一旦设为static,数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象,仍能调用一个static方法,或访问一些static数据。对方法来说,static一项重要的用途就是帮助我们在不必创建对象的前提下调用方法。

## 2.7 构建Java程序
在每个程序文件的开头,使用import语句,导入用到的额外的类。默认导入每个Java文件的类库:**java.lang**。

在线文档： 
https://docs.oracle.com/javase/8/docs/api/ 


## 2.8 注释和嵌入文档
Java 里有两种类型的注释。
1. 传统C语言风格的注释,是从 C++继承而来的。这些注释用一个“/\*”起头,随后是注释内容,并可跨越多行,最后用一个“*/”结束。
2. 起源于C++的“单行注释”,以一个“//”起头,表示这一行的所有内容都是注释。

### 2.8.1 注释文档
为使一切都整齐划一,还必须使用一种特殊的注释语法,以便标记出特殊的文档;另外还需要一个工具,用于提取这些注释,并按有价值的形式将其展现出来。
用于提取注释的工具叫作 javadoc。它采用了部分来自Java编译器的技术,查找我们置入程序的特殊注释标记。它不仅提取由这些标记指示的信息,也将毗邻注释的类名或方法名提取出来。这样一来,我们就可用最轻的工作量,生成十分专业的程序文档。

javadoc输出的是一个HTML文件,可用自己的Web浏览器查看。该工具允许我们创建和管理单个源文件,并生动生成有用的文档。由于有了javadoc,所以我们能够用标准的方法创建文档。而且由于它非常方便,所以我们能轻松获得所有Java库的文档。

### 2.8.2 具体语法

所有 javadoc 命令都只能出现于“\/\*\*”注释中。但和平常一样,注释结束于一个“*/”。

主要通过两种方式来使用javadoc:嵌入的 HTML,或使用“文档标记”。其中,“文档标记”(Doc tags)是一些以“@”开头的命令,置于注释行的起始处(但前导的“\*”会被忽略)。

有三种类型的注释文档,它们对应于位于注释后面的元素:类、变量或者方法。也就是说,一个类注释正好位于一个类定义之前;变量注释正好位于变量定义之前;而一个方法定义正好位于一个方法定义的前面。如下面这个简单的例子所示:

```
/** 一个类注释 */
public class docTest {
/** 一个变量注释 */
public int i;
/** 一个方法注释 */
public void f() {}
}
```

注意 javadoc 只能为 public(公共)和 protected(受保护)成员处理注释文档。“private”(私有)和“友好”(详见 5 章)成员的注释会被忽略,我们看不到任何输出(也可以用-private 标记包括 private 成员)。这样做是有道理的,因为只有 public 和 protected 成员才可在文件之外使用,这是客户程序员的希望。然而,所有类注释都会包含到输出结果里。

### 2.8.3 嵌入HTML

javadoc将HTML命令传递给最终生成的HTML文档。

